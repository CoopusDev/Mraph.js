(()=>{"use strict";const t=class{constructor(...t){this.color="black",this.visible=!0,this.fillColor="rgba(0,0,0,0)",!1!==t[t.length-1]&&mraph.elements.push(this)}resizeTo(t,e,i){let s,n;mraph.animation.add(e,i,{start:()=>{s=this.size,n=s*t-s},update:t=>{this.size=s+n*t}})}},e=class extends t{constructor(t,e,i){super(i),this.size=10,this.x=t,this.y=e}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.lineWidth=2*this.size,t.fillStyle=this.color,t.arc(this.x,this.y,this.size,0,2*Math.PI),t.fill(),this}moveTo(t,e,i){let s,n,h,o;const a=this;mraph.animation.add(e,i,{start:()=>{t=mraph.getPos(t),s=a.x,n=a.y,h=t[0]-s,o=t[1]-n},update:t=>{a.x=s+h*t,a.y=n+o*t}})}},i=class extends t{constructor(t,e,i){super(i),this.size=5,this.point1=mraph.getPoint(t),this.point2=mraph.getPoint(e)}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.lineWidth=this.size,t.strokeStyle=this.color,t.moveTo(this.point1.x,this.point1.y),t.lineTo(this.point2.x,this.point2.y),t.stroke(),this}get length(){return Math.hypot(this.point2.x-this.point1.x,this.point2.y-this.point1.y)}get slope(){return(this.point2.y-this.point1.y)/(this.point2.x-this.point1.x)}};class s{constructor(t){const e=this,i=new Map;this.events=i,this.isStarted=!1,this.isEnded=!1,i.set("start",(function(){t.start&&t.start(),e.isStarted=!0})),i.set("update",(function(e){t.update&&t.update(e)})),i.set("end",(function(){t.end&&t.end(),e.isEnded=!0}))}add(t){return new s({start:()=>{this.events.get("start")(),t.events.get("start")()},update:e=>{this.events.get("update")(e),t.events.get("update")(e)},end:()=>{this.events.get("end")(),t.events.get("end")()}})}}const n={frameList:new Map,start(){const t=+new Date,e=this.startTime,i=this.endTime,s=this.frameList;this.add(e/1e3,i/1e3,{update:()=>{mraph.background(),mraph.draw()}}),function n(){const h=+new Date-t;let o;if(h>i&&0===s.size)cancelAnimationFrame(o);else if(h>e){for(let[t,e]of s)h>t[0]&&t[1]>h?(e.isStarted||e.events.get("start")(),e.events.get("update")((h-t[0])/(t[1]-t[0]))):h>t[1]&&(e.events.get("update")(1),e.events.get("end")(),s.delete(t));o=requestAnimationFrame(n)}else o=requestAnimationFrame(n)}()},add(t,e,i){const n=[t*=1e3,e*=1e3],h=this.frameList,o=new s(i);h.has(n)?h.set(n,o.add(h.get(n))):h.set(n,o),void 0!==this.startTime?t<this.startTime&&(this.startTime=t):this.startTime=t,void 0!==this.endTime?e>this.endTime&&(this.endTime=e):this.endTime=e}},h={elements:[],setup(t,e){const i=document.createElement("canvas");t.appendChild(i),e&&(e.width&&(i.width=3*e.width,i.style.width=e.width+"px"),e.height&&(i.height=3*e.height,i.style.height=e.height+"px")),this.canvas=i},draw(){const t=this.elements;for(const e of t)e.draw()},background(t="white"){this.ctx2d.fillStyle=t;const e=this.canvas.width,i=this.canvas.height;this.ctx2d.fillRect(-e/2,-i/2,e,i)},getPoint:t=>t instanceof e?t:new e(...t,!1),getPos:t=>t instanceof e?[t.x,t.y]:t,set canvas(t){this._canvas=t;const e=t.getContext("2d");this.ctx2d=e,e.translate(t.width/2,t.height/2),e.scale(1,-1)},get canvas(){return this._canvas}};h.Point=e,h.Segment=i,h.Line=class extends i{constructor(...t){super(...t),this.color="#C61C1CFF"}draw(){if(!this.visible)return;const t=mraph.ctx2d;t.beginPath(),t.lineWidth=this.size,t.strokeStyle=this.color;const e=mraph.canvas.width,i=mraph.canvas.height,s=this.point1,n=this.point2;if(n.x-s.x!=0){const i=this.slope;t.moveTo(-e/2,s.y+(-e/2-s.x)*i),t.lineTo(e/2,n.y+(e/2-n.x)*i)}else t.moveTo(s.x,-i/2),t.lineTo(s.x,i/2);return t.stroke(),this}},h.Circle=class extends t{constructor(t,e,i){if(super(i),this.size=5,this.color="#F05D11FF",this.fillColor="#F05D1199",this.point1=mraph.getPoint(t),"[object Number]"==Object.prototype.toString.call(e)){const t=new mraph.Point(this.point1.x+e,this.point1.y);t.visible=!1,this.point2=t}else this.point2=mraph.getPoint(e)}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.strokeStyle=this.color,t.fillStyle=this.fillColor,t.lineWidth=this.size,t.arc(this.point1.x,this.point1.y,this.radius,0,2*Math.PI),t.stroke(),t.fill(),this}get radius(){return Math.hypot(this.point2.x-this.point1.x,this.point2.y-this.point1.y)}},h.animation=n,window.mraph=h})();