(()=>{"use strict";const t=class{constructor(...t){this.color="black",this.visible=!0,this.fillColor="rgba(0,0,0,0)",!1!==t[t.length-1]&&mraph.elements.push(this)}resizeTo(t,i,e){let s,n;mraph.animation.add(i,e,{start:()=>{s=this.size,n=s*t-s},update:t=>{this.size=s+n*t}})}},i=class extends t{constructor(t,i,e){super(e),this.size=10,this.x=t,this.y=i}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.lineWidth=2*this.size,t.fillStyle=this.color,t.arc(this.x,this.y,this.size,0,2*Math.PI),t.fill(),this}moveTo(t,i,e){let s,n,h,o;const a=this;mraph.animation.add(i,e,{start:()=>{t=mraph.getPos(t),s=a.x,n=a.y,h=t[0]-s,o=t[1]-n},update:t=>{a.x=s+h*t,a.y=n+o*t}})}},e=class extends t{constructor(t,i,e){super(e),this.size=5,this.point1=mraph.getPoint(t),this.point2=mraph.getPoint(i)}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.lineWidth=this.size,t.strokeStyle=this.color,t.moveTo(this.point1.x,this.point1.y),t.lineTo(this.point2.x,this.point2.y),t.stroke(),this}get length(){return Math.hypot(this.point2.x-this.point1.x,this.point2.y-this.point1.y)}get slope(){return(this.point2.y-this.point1.y)/(this.point2.x-this.point1.x)}};class s{constructor(t){const i=this,e=new Map;this.events=e,this.isStarted=!1,this.isEnded=!1,e.set("start",(function(){t.start&&t.start(),i.isStarted=!0})),e.set("update",(function(i){t.update&&t.update(i)})),e.set("end",(function(){t.end&&t.end(),i.isEnded=!0}))}add(t){return new s({start:()=>{this.events.get("start")(),t.events.get("start")()},update:i=>{this.events.get("update")(i),t.events.get("update")(i)},end:()=>{this.events.get("end")(),t.events.get("end")()}})}}const n={frameList:new Map,start(){const t=+new Date,i=this.startTime,e=this.endTime,s=this.frameList;this.add(i/1e3,e/1e3,{update:()=>{mraph.background(),mraph.draw()}}),function n(){const h=+new Date-t;let o;if(h>e&&0===s.size)cancelAnimationFrame(o);else if(h>i){for(let[t,i]of s)h>t[0]&&t[1]>h?(i.isStarted||i.events.get("start")(),i.events.get("update")((h-t[0])/(t[1]-t[0]))):h>t[1]&&(i.events.get("update")(1),i.events.get("end")(),s.delete(t));o=requestAnimationFrame(n)}else o=requestAnimationFrame(n)}()},add(t,i,e){const n=[t*=1e3,i*=1e3],h=this.frameList,o=new s(e);h.has(n)?h.set(n,o.add(h.get(n))):h.set(n,o),void 0!==this.startTime?t<this.startTime&&(this.startTime=t):this.startTime=t,void 0!==this.endTime?i>this.endTime&&(this.endTime=i):this.endTime=i}},h={elements:[],draw(){const t=this.elements;for(const i of t)i.draw()},background(t="white"){this.ctx2d.fillStyle=t;const i=this.canvas.width,e=this.canvas.height;this.ctx2d.fillRect(-i/2,-e/2,i,e)},getPoint:t=>t instanceof i?t:new i(...t,!1),getPos:t=>t instanceof i?[t.x,t.y]:t,set canvas(t){this._canvas=t;const i=t.getContext("2d");this.ctx2d=i,i.translate(t.width/2,t.height/2),i.scale(1,-1)},get canvas(){return this._canvas}};h.Point=i,h.Segment=e,h.Line=class extends e{constructor(...t){super(...t),this.color="#C61C1CFF"}draw(){if(!this.visible)return;const t=mraph.ctx2d;t.beginPath(),t.lineWidth=this.size,t.strokeStyle=this.color;const i=mraph.canvas.width,e=mraph.canvas.height,s=this.point1,n=this.point2;if(n.x-s.x!=0){const e=this.slope;t.moveTo(-i/2,s.y+(-i/2-s.x)*e),t.lineTo(i/2,n.y+(i/2-n.x)*e)}else t.moveTo(s.x,-e/2),t.lineTo(s.x,e/2);return t.stroke(),this}},h.Circle=class extends t{constructor(t,i,e){if(super(e),this.size=5,this.color="#F05D11FF",this.fillColor="#F05D1199",this.point1=mraph.getPoint(t),"[object Number]"==Object.prototype.toString.call(i)){const t=new mraph.Point(this.point1.x+i,this.point1.y);t.visible=!1,this.point2=t}else this.point2=mraph.getPoint(i)}draw(){if(!this.visible)return;const t=mraph.ctx2d;return t.beginPath(),t.strokeStyle=this.color,t.fillStyle=this.fillColor,t.lineWidth=this.size,t.arc(this.point1.x,this.point1.y,this.radius,0,2*Math.PI),t.stroke(),t.fill(),this}get radius(){return Math.hypot(this.point2.x-this.point1.x,this.point2.y-this.point1.y)}},h.animation=n,window.mraph=h})();